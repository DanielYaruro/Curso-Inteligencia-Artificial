# -*- coding: utf-8 -*-
"""Course_IA class1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gV3MCYbiI2LURujGH0O0u14ZItAireFp
"""

import numpy as np

#Creando listas de dtos
listas1 = [1, 5, 8, 10]
print(listas1)
listas2 = ["inteligencia", 4.223, 3, 16, False]
print("listas2 =", listas2)

listas3 = [[8,2,9], [35, 44, 19], [63,41,75]]

print("listas3 =", listas3)

#Creando arreglos desde listas

n = [[1.25,2,3],
 [np.pi, 44, 212],
     [19.1, 21.9, 0.00045],
     [14,2,4]]

#Arreglo multidimensional
m = np.array(n)
print("Tipo de dato: ", m.dtype)
print("Forma del arreglo: ", m.shape)
print("Tamaño del arreglo: ", m.size)
print("Dimension del arreglo: ", m.ndim)
print(n)

arreglo = [21,32,58,47]

m = np.array(arreglo, dtype= "float16" )
print("Tipo de dato: ", m.dtype)
print("Forma del arreglo: ", m.shape)
print("Tamaño del arreglo: ", m.size)
print("Dimension del arreglo: ", m.ndim)
print(m)

"""Redimensionando los arreglos"""

arr = np.array([[1, 2, 3, 4, 5],
                [4, 5, 6, 7, 8]])


print("Tipo de dato: ", arr.dtype)
print("Forma del arreglo: ", arr.shape)
print("Tamaño del arreglo: ", arr.size)
print("Dimension del arreglo: ", arr.ndim)
print(arr)

#Manera de cambiarle la forma a la matriz de varias dimensiones

arr = np.array([[1, 2, 3, 4, 5],
                [4, 5, 6, 7, 8]], dtype = 'float64')
#Ejemplo de como redimensionar la dimension de un arreglo
arr.shape = (5,2)
print("Tipo de dato: ", arr.dtype)
print("Forma del arreglo: ", arr.shape)
print("Tamaño del arreglo: ", arr.size)
print("Dimension del arreglo: ", arr.ndim)
print(arr)

#Otras formas de crear arreglos

#Arreglo de tres dimensiones

mat = np.arange(36).reshape(3,4,3)

print(' Tipo de dato = ', mat.dtype)
print(' Shape del arreglo = ', mat.shape)
print(' Tamaño del arreglo = ', mat.size)
print(' Dimensiones del arreglo = ', mat.ndim)
print(mat)

#Trayendo todos los elementos de la dimension 0, fila 0, todas las columnas
print('Dimension 0, toda la primera fila', mat[0,0,:])
print('Dimension 0, toda la segunda fila', mat[0,1,:])
print('Dimension 0, toda la tercera fila', mat[0,2,:])

print('Dimension 1, toda la primera columna', mat[1,:,0])
print('Dimension 1, toda la segunda columna', mat[1,:,1])
print('Dimension 1, toda la tercera columna', mat[1,:,2])

#Traer todos los elementos de una dimension
print('Elementos de la dimension 2\n', mat[2,:,:])

m1 = np.arange(6)
print(m1)

m2 = np.arange(24).reshape(6,4)
print(m2)

#Otra forma de utilizar la funcion arange

m3 = np.arange(0,10,3).reshape(4,1)
print(m3)

#Con incremento negativo
m4 = np.arange(50,14,-5).reshape(2,2,2)
print(m4)

#Utilizando la funcion linspace en python

m = np.linspace(1,20,9, dtype='float64').reshape(3,3)
print(m)

#Utilizando la funcion logspace en python
m = np.logspace(2,3,10, dtype='float64')
print(m)

#Utilizando las funciones zeros y ones

m_1 = np.zeros(shape=(2,4,3), dtype='int64') #Array
print(m_1)
print('\n')
m_2 = m_1 = np.ones(shape=(4,3), dtype='int64') #Array
print(m_1)

#Si quiero dejar que python me defina la cantidad de columnas o filas en base a otros parametros
m_3 = np.arange(27).reshape(-1,3,3)
print('Tamaño:',m_3.size, 'Dimensiones:', m_3.ndim, 'Shape:', m_3.shape)
print('\n')
print(m_3)

#Metodo flatten()
m = np.arange(27).reshape(-1,3,3)
b = m.flatten()
#Aplana todos los valores a una sola dimension
print(b)

arreglo = []
for i in range(1,300, 12):
  arreglo.append(i)


def rellenar(inicio, final, step):
   arreglo = []
   for i in range(inicio, final, step): arreglo.append(i)
   return np.array(arreglo)

mat = np.array(arreglo, dtype="int64")
#En shape primero filas y luego columnas
mat.shape = (5,5)
print(mat)

a = np.reshape(np.array(range(1,26)), (5,5))
print(a)
print(a[-2])
b = a[-1:,-1:]
print(b)

#Trabajando con mascaras

a = np.array([1,2,3,4,5,6,7])
mascara = a > 3

print(a)
print(mascara)
print(a[mascara])

#Mascaras con booleanos

a_2 = np.array([1,2,3,4,5,6,7])
mascara_2 = [True, True, False, True, False, False, False]
print(a_2)
print(mascara_2)
print(a_2[mascara_2])

#Modificar arreglos con mascaras

a = np.array([1,2,3,4,5,6,7])
mascara = a > 3

print(a)
print(mascara)
a[mascara] = 0
print(a)
print(a[mascara])

#Fancy indexing o indexacion elegante

a = np.reshape([np.array(range(1,26))], (5,5))
print('a: \n',a)
print('\n a[[3,1]] \n')
#Extraigame las filas 3 y 1 en ese orden e imprimalas
print(a[[3,1]])
#En esa filas extraigame el elemento (n,m)

print()
print('a[[3,1], [2,0]]')
print(a[[3,1], [2,0]])

#Indexacion y slicing
#Extramos la primera fila y la primera columna del arreglo
print(mat[0][0])

#Traemos la primera fila
print(mat[0])

print(mat[-1][-1])

#Traemos la ultima fila
print(mat[-1])
print()
#Slicing
print(mat[3:4])
print()
print(mat[-1:1])

#Tener en cuenta que en los slicing si se quiere rebanar y guardar en una variable se debe hacer la copia con el metodo .copy()

"""Aranges, te rellena una matriz del tamaño que le pongas"""

#print(numeros)

numbers = np.arange(20)
print(numbers)
print()
print(numbers[1:12:2])
print(numbers[-4:-1])

#En este slicing le estamos diciendo que empieze en 12 y
#llegue hasta el 1 y incremente hacia abajo 2
print(numbers[12:1:-2])

#Manera de cambiar un elemento de un arreglo conociendo su indice
numeros = rellenar(10, 100, 7)
print(numeros)

numeros[3] = 13

print(numeros)
print(len(numeros))
#Manera de cambiar varios elementos de un arreglo con slicing

#Dato curioso si le metes mas numeros de los que vas a cambiar va a adicionar los otros nuevos numeros, como otra manera de añadir elementos a los indices
numeros[3:12] = [0,1,2,3,4,5,6,7,8,9,10]
print(numeros)
print(len(numeros))

## Manejo de Numeros Aleatorios (random)

np.random.seed(0) #Establecemos una semilla y al volver a usarla nos dara los mismos numeros aleaotorios
print('Serie #1', np.random.rand(3)) #Creamos un vector de 3 numeros aleatorios

np.random.seed(0)
print('Serie #2', np.random.rand(3))

print('Escalar: ', np.random.rand()) #Genera un solo numero aleatorio si no le pasamos un argumento
print('Vector', np.random.rand(3)) #Genera un vector de 3 posiciones
print('Matriz\n', np.random.rand(3,3)) #Genera una matriz del tamaño que le demos (3x3)

#Ejemplo con distribucion normal
import matplotlib.pyplot as plt

np.random.seed(12)#semilla

campana_gauss = np.random.randn(10000) #Valores con distribucion normal con randn
plt.hist(campana_gauss,bins=1000)
plt.show() #Histograma con 1000 bins o banderas

#VECTORIZACION

#La vectorizacion permite realizar operaciones en conjuntos de datos de manera simultanea en vez de iterar sobre ellos uno por uno, para asi en vez de utilizar
#bucles explicitos se aprovecha las capacidades de calculo que ofrece numpy

#Ademas se puede hacer filtrado de elementos de un arreglo, ordenar un arreglo y aplicar transformaciones a un arreglo

lista_A = [[20, 37, 51, 10],
           [85, 28, 20, 47],
           [20, 52, 95, 38]]

lista_B = [[12, 45, 63, 3],
           [10, 24, 5, 25],
           [52, 12, 0, 8]]

A = np.array(lista_A)
B = np.array(lista_B)

print('Operacion Suma: Suma elemento con elemento de las mismas posiciones a1_1+b1_1, a1_2+b1_2, ... an_n+bm_m\n', A+B)

#Funciones Trigonometricas
#SENO
#Suponiendo que A esta en grados, lo pasamos a radianes
A_rad = np.radians(A)
print('Sen(A):\n', np.sin(A_rad))

#Comparacion
print('A>B: \n', A > B) #Devuelve los booleanos de los valores de A comparados con los valores de B de la misma posicion

#Filtrar numeros
umbral = 50
#Devuelve los numeros que esten en el arreglo que sean mayores al umbral
print('A>umbral: \n', A[A>umbral])

#Maneras de ordenamiento

print('Matriz A organizado ascendentemete: \n', np.sort(A)) #Lo que hace es ordenar las filas de izquierda a derecha

#AXIS
#Si se tiene un array de tres dimensiones, axis=0 se refiere al eje x(filas), axis = 1, se refiere al eje y(columnas), y axis = 3, se refiere al eje z(dimensiones)
A = np.array([[1, 2, 3], [4, 5, 6]])
print('A: \n', A)

#Suma todos los elementos del array
total = np.sum(A)
print('Suma todos los elementos de A', total)

#Computar la suma a lo largo de las filas, axis=0 (rows)
filas_sum = np.sum(A,axis=0)
print("El total de los elementos de las filas( eje x ) es", filas_sum) #Suma las columnas y da el resultado de cada columna sumada
columnas_sum = np.sum(A, axis=1)
print('El totla de los elementos de las columnas (eje y) es', columnas_sum) #Suma toda la fila y da el resultado de la suma de cada fila

#Computar el minimo a lo largo de las filas
print('El minimo a lo largo de las filas de A es', np.min(A,axis=0)) #Agarra el minimo de cada columna y lo imprime de acuerdo a la cantidad de columnas que haya

print('El minimo a lo largo de las columnas de A es', np.min(A,axis=1)) #Agarra el minimo de cada fila y lo imprime de acuerdo a la cantidad de filas que haya

#Funciona exactamente igual con el maximo [Funcion max()]

"""## Broadcasting

Tratamiento de matrices con diferentes formas
"""

#Agregar una matriz unidimensional a una matriz multidimensional

A = np.array([[0, 0, 0],
              [10, 10, 10],
              [20, 20, 20],
              [30, 30, 30]], dtype='float64')

B = np.array([1, 2, 3], dtype='float64')
C = np.array([1.0, 2.0, 3.0, 4.0])

print("A + B: \n", A + B)

"""### Concatenacion

Poner el contenido de dos o mas matrices en una sola matriz, las matrices deberan ser de igual tamaño
"""

lista_A = [[4, 7, 8, 10],
           [6, 12, 15, 0],
           [1, 6, 8, 10]]

A = np.array(lista_A)
lista_B = [[2, 3, 6, -2],
           [6, 5, 2, 0],
           [-3, 15, 2, 0]]

B = np.array(lista_B)

C = np.array([[2, 3, 6, -2],
              [6, 5, 2, 0]])

D = np.array([[4, 7],
              [6, 12],
              [1, 6]])

#Concatenar A con B (por defecto es a lo largo de las filas)
R = np.concatenate((A,B), axis=0) #Por defecto es axis = 0
print('A concatenada con B\n', R) #Pego la matriz por debajo A debajo B

#Concatenar A con B a lo largo de las columnas
R1 = np.concatenate((A,B), axis=1)
print("A concatenada con B\n", R1) #Pego la matriz B a la derecha de A

R2 = np.concatenate((A,B,C), axis=0)
print(" A concat con B concat con C a lo largo de las filas: \n", R2)

'''
R3 = np.concatenate((A,B,C), axis=1) Va a dar error porque no son tamaños compatibles
R4 = np.concatenate((A,B,D), axis=0) Va a dar error porque no son tamaños compatibles

'''

R5 = np.concatenate((A,B,D), axis=1)
print("A concat B concat D va a pegar las matrices hacia la derecha: \n ", R5)

mat_D = R5[:,8:].copy()

print('\n', mat_D)